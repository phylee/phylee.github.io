<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="时间过的很快，我在涂鸦工作已经超过三年了，其实从入职的第一天起我从来没想过在这家公司能呆三年，然而世事难料吧。三年不算长，但也是我毕业后工作经历中很重要的三年，所以也该写一个总结，回首过往，总结经验，是为了更好的面对未来的挑战。下面的回顾文字，可能会有马后炮的嫌疑（当然任何回顾总结都有这种嫌疑），只作为个人工作的一小段总结，留作以后回顾，不作其他的引申。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>我的涂鸦三年 | Phylee的小站</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.0.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Work/" rel="tag">Work</a></div><div class="post-time">2022-05-03</div></div></div><div class="container post-header"><h1>我的涂鸦三年</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#2019%E5%B9%B4%EF%BC%9A%E6%89%93%E6%89%AB%E5%B9%B2%E5%87%80%E5%B1%8B%E5%AD%90"><span class="toc-number">1.</span> <span class="toc-text">2019年：打扫干净屋子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2020%E5%B9%B4%EF%BC%9A%E5%86%8D%E8%AF%B7%E5%AE%A2"><span class="toc-number">2.</span> <span class="toc-text">2020年：再请客</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2021%E5%B9%B4%EF%BC%9A%E5%8F%A6%E8%B5%B7%E7%82%89%E7%81%B6"><span class="toc-number">3.</span> <span class="toc-text">2021年：另起炉灶</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%B6%E5%B0%BE"><span class="toc-number">4.</span> <span class="toc-text">收尾</span></a></li></ol></details></div><div class="container post-content"><p>时间过的很快，我在涂鸦工作已经超过三年了，其实从入职的第一天起我从来没想过在这家公司能呆三年，然而世事难料吧。三年不算长，但也是我毕业后工作经历中很重要的三年，所以也该写一个总结，回首过往，总结经验，是为了更好的面对未来的挑战。下面的回顾文字，可能会有马后炮的嫌疑（当然任何回顾总结都有这种嫌疑），只作为个人工作的一小段总结，留作以后回顾，不作其他的引申。</p>
<h2 id="2019年：打扫干净屋子"><a href="#2019年：打扫干净屋子" class="headerlink" title="2019年：打扫干净屋子"></a>2019年：打扫干净屋子</h2><p>第一年，刚入职不久，公司员工陆陆续续离职（当然后面我又再次遇到这种场景），当时的我也不是很熟悉现有平台的开发语言，入职前我主要写的是Python，也没怎么写过前端，现有平台后端是Java，前端是Vue.js。平台功能大而全所以也很复杂，基本都是自研的，同时也有些稳定性的问题，挑战对当时的我来说是前所未有的，所以头一年基本上也没有休息好一个完整的周末和假期。</p>
<p>首要工作就是要保证平台的稳定性。要保证稳定就需要化繁为简，复杂性是软件工程上的万恶之源，因为人天生就不愿意处理很复杂的东西，更别说还需要长时间的维护；其次要聚焦平台的主航道，人力有限无法面面俱到的情况下，要优先保证平台的核心功能稳定可靠，其他次要功能能砍则砍，不能砍的也不再投入过多时间，要逐步下掉。</p>
<p>这一年主要做的工作：</p>
<blockquote>
<ol>
<li><p>推：优先级较低的新功能需求推掉或延期支持，先保证发布核心功能的稳定。</p>
</li>
<li><p>砍：不重要的或者不需要的功能先砍掉。<br>例如：下线工单相关、vpn权限管理、机器权限管理、需求管理等等，同时清理大量毁弃的代码。</p>
</li>
</ol>
<p>新的运维平台支持工单功能，就将现有的工单下掉了。<br>需求管理这块本来是需要的也是重要的，对发布平台来说，从需求管理到上线是个完整的生命周期，但是人力有限，也忍痛砍掉了（后面公司成立单独的效能团队，做了一个新的项目中心平台，当然这是后话）。</p>
<ol start="3">
<li><p>迁：和发布平台核心不相关的功能迁移，专注自身的平台定位。<br>例如：日志报警，健康检查报警等迁移到监控平台，机器管理等相关迁移新的运维平台。</p>
</li>
<li><p>优：故障频发的接口重点优化。使用频繁和问题多的接口能重构的重构，能优化的优化，维护成本高的难以优化的就弃用。<br>集中一段时间修复bug，当然有些也不能算bug，只是接口校验写得不够严谨，提示信息不够明确，会导致大量的答疑的工作。大量bug，会导致大量时间浪费在定位以及处理数据不一致的问题，无法开展新的功能特性开发。同时接口中增加一些防御性检查，避免误操作。例如前端输入增加长度限制，避免超过数据库字段限制。增加重试，减少网络问题影响等等。在和其他平台对接时，要避免其他平台异常导致自身平台无法使用的情况，可降级，避免强依赖（当然有些强依赖是无法完全解耦的）。<br>关于bug，很多人觉得平台要做到零bug，发现bug就要立即修复甚至当天修复。我的看法是bug永远都修复不完的，也不可能投入所有精力去修复全部bug。只要开发新的功能特性就会有新的bug，我们要做的是保证bug降低一定范围以下同时优先级足够低即可。要重视bug但是不能被bug绊住平台演进的脚步。</p>
</li>
<li><p>改：我们同时进行了一个大的改造，proxy重写为gateway。<br>这次大重写一方面是为了稳定性，另一方面也是为了减少我们额外支撑时间。原有的发布过程中的日志显示的很不友好，这样开发人员很多时候就不能自助定位失败问题，就会频繁找我们，浪费我们大量的支撑时间，当然也会浪费开发人员大量的找人时间。原来部署脚本都是在机器上，升级更新很麻烦，这次重写也考虑了这个问题，将部署的脚本统一收到平台管理，在部署时自动下发。极大地降低了原来机器上脚本的不一致性问题和升级成本，同时让我们也能更方便的灰度发布更新这些脚本。<br>此次重写也让我们发生了一个导致业务的线上故障，主要原因就是脚本的不一致性导致的，这也是我们收回平台统一管理的原因，当然这不能让我们停止重构，任何重构都有的风险可能导致新的故障，只要重构收益大，我们就不能束手束脚，否则故障只是早晚的事。基本的处理原则是：事前充分准备尽量避免，事中要尽量可灰度升级，事后要能做到快速回滚。基本能做到这三点，风险就可以很大地降低。</p>
</li>
<li><p>减：减少处理“杂事”的时间。<br>一开始平台上有大量的事情，需要平台管理员处理，这会占用我们不少的开发时间，当然这也不符合我的平台理念，平台当然要像ATM机器一样能自助，一个开发团队可以在平台上做任何他们需要做的事（当然不是每一个开发人员都有所有权限，但是团队负责人或者应用负责人是可以有的），除非平台自身有问题才需要找我们处理。于是我们花费了一些精力将平台管理员的权限能转移给主管的转给主管，能转移给应用负责人的就转移给应用负责人。减少平台管理员花费大量时间在处理平台上用户权限不够的问题上。<br>理想情况下，平台的用户不需要找管理员要任何权限，因为我们做的平台应该是自助的，当然自助就有可能发生一些非主观的问题甚至故障，所以我们要做好平台用户的使用培训，对一些危险操作要二次确认，多次校验，事后要有操作日志可回溯。当然不能害怕用户犯错，就不放权，这些操作错误有些是平台自身设计的不太好，运用“防呆”的设计思想，不断优化平台的使用体验，可以让我们以后减少类似错误。</p>
</li>
<li><p>易：让平台自身做到更容易的发布，减少部署时间花费。<br>我们平台发布的应用都是使用docker镜像部署，这很好，这也减少后面我们迁移k8s的成本，但是发布平台自身却不是，这个是不合适的，做平台首先要eat our own dog food。我花了一点时间，让平台自身的各个应用都迁移使用docker镜像部署，同时使用Gitlab的CI合并代码后自动构建镜像，尽量减少手动操作。当然最好是平台自己能发布自己，要像某些编程语言那样具有自举的能力（因为平台自身的一些设计问题，我们当时没能做到自己发布自己，后面做新平台时我们做到了，当然这是后话）。</p>
</li>
</ol>
</blockquote>
<p>这一年我的主要精力都是在修修补补，手起刀落，快刀斩乱麻，过程中我也犯了一些错误甚至导致一些故障，但是结果还是不错的，在同事的共同努力下，我们让平台更加稳定了，同时赋予平台用户更多的自助能力，让它更像一个“ATM式”的平台了。做到这些是不容易的，当然这些都离不开当时同事的协作。要做好一件事，一个人当然是很难的，更需要有多个团队成员之间的协同配合。所以有些人在一个公司做的很好，换一个公司好像就没法做的像原来一样，大概也有这个原因吧。</p>
<h2 id="2020年：再请客"><a href="#2020年：再请客" class="headerlink" title="2020年：再请客"></a>2020年：再请客</h2><p>经过上一年的不断完善，平台基本稳定了，同时平台的代码我们也熟悉了，新的一年我们要再出发。</p>
<p>这一年我们做了很多新的功能特性，增强并扩展了平台的持续交付的能力。</p>
<blockquote>
<ol>
<li>拥抱云原生：由虚拟机部署走向k8s部署<br>从19年底我们就开始初步试点k8s部署，试点没大问题后，在2020年我们开始了大规模的迁移。<br>因为原来虚拟机部署也是用的docker镜像作为制品进行发布的，所以这也让我们迁移k8s更容易，改造成本更低。最大的难度可能是分批部署，我们主要是服务端的应用发布，能分批，小规模灰度很重要，但是k8s的原生工作负载Deployment不支持分批暂停，所以我们内部的k8s团队基于Deployment自研了一个CRD，很好的解决了这个问题。<br>发布平台方面在设计的时候我们要考虑到迁移后如果有问题，如何能快速回滚回去？是按照一个应用整体迁移，还是按照环境进行迁移？当然我们公司在全球有多个数据中心，多个公有云厂商，不同云厂商的k8s支持程度不一样，还是按照区域去迁移？这些都是我们要考虑的细节。还有迁移的时间可能会很长，我们也要考虑迁移过程的兼容性问题，尽量无感知迁移，减少故障。</li>
</ol>
<p>迁移之后的配套设施支持也是一个问题，其他内部平台的协同支持也很重要，因为k8s对我们来说还是个新的“物种”，如何让开发人员适应它，了解它，也是需要很多培训和文档支持的。</p>
<ol start="2">
<li><p>新增项目维度的隔离测试环境：稳定性和灵活性的权衡，机器成本和人力成本的权衡。<br>微服务越来越多，开发人员也越来越多，测试环境的稳定性就会遇到很大的挑战。需求越来越多，大家都要测试，但是测试环境就几个，大家都在里面部署，而且代码还是未经充分测试的，一个被依赖性的服务代码有问题，就可能导致很多的依赖服务的测试不了，特别是底层的服务，出现故障，会导致大量的项目测试无法进行，很影响很多开发人员和测试人员的工作效率。</p>
<p>于是今年我们对日常测试环境做了一些改造，让原来的日常环境只部署线上最新代码并且可以线上发布完自动更新部署，同时虚拟出一个测试的隔离环境，按照一个需求一个项目，将该需求的相关多个应用部署到一个隔离环境，打上一个唯一的标签，然后基于该标签进行流量路由。其实有点写时复制的思想，当你交付的一个需求要修改的多个应用时，就新建一个项目将相关应用关联起来，打上唯一的标签进行部署，不需要修改代码的但是测试需要依赖的应用就使用日常部署了master主干代码的基础环境。这样可以用最少的机器同时可以虚拟出无数个测试的隔离环境（因为都打上了唯一的标签，标签之间的应用不会直接调用，看起来是完全隔离的）。</p>
<p>当然这是需要前端，客户端，云端，测试团队等多部门协作和支持这个唯一标签的流量路由，不单单靠一个发布平台就能搞定的。</p>
</li>
<li><p>持续集成的资源改造：由单机走向集群。</p>
</li>
</ol>
<p>随着应用和开发人员的增多，任务类型也由原来的只有编译打包扩展到单元测试，代码扫描等多种类型任务，原来只有一台虚拟机用来编译打包，配置也越升越高，已经无法满足任务增长的需求，所以我们需要进行改造。但是缺少一个任务调度和资源管理的平台，我们人力有限也不可能去自研开发一个，正好我们在迁移k8s,  所以经过多方调研，我觉得使用k8s作为调度和资源池管理平台是最好的方式，同时我们引入开源的Tekon作为CI/CD引擎，最后顺利的从单机迁移到k8s集群。</p>
<p>其实基于k8s做CI/CD也是我一直以来想做的，就是从下载代码，编译打包，单元测试，构建镜像，部署等完整流程，都可以在一个k8s集群完成，完全闭环，也方便迁移。这样我们可以充分利用k8s的能力，例如弹性扩缩容，不同资源大小的调度能力等等，减少重复造轮子，在巨人的肩膀上我们才能走得更快更远。</p>
<ol start="4">
<li><p>多架构镜像部署：由单架构走向多架构。<br>ARM架构的机型价格相对便宜很多，但是我们是多云的，有些云厂商的还不支持ARM架构的机器，所以我们要同时支持ARM64和x86-64两种架构的编译和镜像构建。我们通过调研，主要利用社区的docker mainfest和buildx两种方式。本来想大规模使用buildx的，因为这个工具太好了，可以一次打包多种架构的镜像。但是这个工具还在开发中，并不是生产可用的，稳定性还不是太好，社区还在完善迭代中，所以只有小部分场景在使用。主要还是用原生的docker manifest。这里要感谢docker社区优秀的多架构镜像manifest的设计，让我们的实施落地简单了许多。</p>
</li>
<li><p>研发质量提升<br>我们支持了单元测试，代码扫描，对接研测平台，对依赖包进行检测等等，当然平台虽然提供了基本的能力，但是使用的还不太理想，可能主要是我当时的时间精力有限，而且有些地方还没想好，所以这方面时间投入也比较少，也没有持续的去优化。（后续我们在新平台上投入了一些时间对这一块进行了重新的设计，留待后期有时间再写）</p>
</li>
</ol>
</blockquote>
<p>这一年有些工作是超出我的预期的，也许是我的同事们都很优秀吧。从虚拟机往k8s集群的迁移我原以为需要更长的时间，但实际这一年结束我们已经迁移的差不多，还剩下的小部分应用留待后面慢慢迁移了。基于k8s集群的发布后续将作为我们发布平台的“主战场”。</p>
<h2 id="2021年：另起炉灶"><a href="#2021年：另起炉灶" class="headerlink" title="2021年：另起炉灶"></a>2021年：另起炉灶</h2><p>这一年因为组织架构调整，团队成员也增加了不少，希望整合原有的发布平台和运维平台，做一个新的统一的研发平台。减少开发人员多平台的使用成本，同时对原先平台设计不合理地方进行重新设计。</p>
<p>这一年的主要工作的简单思考：</p>
<blockquote>
<ol>
<li><p>重新梳理的已有的所有功能，加深理解，重新优化。<br>原来的平台功能很多，但是没有完全整理过，这次进行了梳理，对发布平台的已有功能有更深的理解，例如应用，项目，编译构建，部署，流水线等等模块的划分。</p>
</li>
<li><p>如何从零开始做一个项目？<br>设计文档，我们要做哪些功能，提供哪些能力？<br>需求整理，我们如何去迭代，先做哪些，后做哪些？<br>服务划分，我们要分几个应用，模块如何划分？<br>原型设计，前端如何展示和交互？<br>迭代开发，如何分解任务、评估开发时间和人员分工?<br>开发完成，如何测试，如何上线，如何推广，如何迁移？</p>
</li>
<li><p>对当前平台架构的思考：原有发布平台和运维平台有些职责不清，如何进行整合并调整定位？个人愚见，仅供笑谈。<br>a) 一种方式是用两个平台：<br>以发布平台为基础，整合扩展为新的研发平台，面向开发人员的一站式平台。也就是只要是开发人员需要的功能只在这一个平台里操作就行，从需求，开发，部署，上线，日志，监控数据反馈一体化。后端数据可以分开多个服务，前端要整合一个页面。<br>以运维平台为基础，整合扩展为多云的管理平台和公司基础运维数据的管理平台，面向运维人员的一站式平台。首先将开发人员需要使用的功能迁移研发平台，避免开发人员多个平台跳转，也就是说这个平台不再对开发人员开放，只面向运维人员，这里的运维是广义的，包括业务运维，系统运维，DBA，k8s集群管理员等等。专注于封装各公有云，私有云的操作，要尽量减少公司内运维人员到各云厂商控制台上的操作，只要在该平台上就可以操作所有云。后期这个平台可以独立部署私有云售卖或者开源。<br>b) 另一种方式是用一个平台：<br>开发人员和运维人员使用的功能整合到一个平台，统一规划，统一管理。</p>
</li>
</ol>
<p>哪种更好？两种思路在我脑海里会经常挣扎。可能如果开发人员较少，公司规模较小时，更适合用一个平台，更容易开发维护。当开发人员多了，规模越来越大时更适合用两个平台，保持协同演进的同时也可以适当独立维护，满足不同场景的需求。当然这中间的界限如何把握是个很难的问题。</p>
<ol start="4">
<li>对重构平台的思考<br>尽量减少新平台从内部开发到对外使用的时间。长时间不对外使用，不可预知的风险（包括技术的和非技术的）就会很高。<br>可以分模块重构，尽量避免从零开始完全重做，因为这样不可避免会导致时间周期很长。这也是微服务的好处。<br>数据库除如果要独立使用，不和老平台复用，要多考虑中间过程数据一致性和迁移的成本。<br>尽量减少重构对平台用户和其他第三方平台的影响。<br>做好一个新项目，技术很重要，好的技术可以让我们把项目做得更快更好，但光关注技术不行，非技术因素也很容易让一个新项目“烂尾”掉。</li>
</ol>
</blockquote>
<p>这一年新平台做的很不容易，中间经历多次公司组织架构调整，项目差点死掉，后又经历开发人员的拆分和减少，各种酸甜苦辣吧，花了近一年多的时间新平台才勉强完全覆盖老平台的所有功能。当然最后的新平台并没有达到我的预期，但是中间没有死掉，还上线了，并替换掉了老平台，也是很不容易的。做这个新平台项目本身没有那么重要，更重要的是让我学到了很多重构项目落地的经验教训吧，毕竟有这样的机会还是比较少的。</p>
<h2 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h2><p>这三年我做了很多平台上的设计，有一些在今天看来已经不是很好了，希望下次会更好吧。很多设计其实都是权衡的结果，没有完美的设计，很多事情都是由当时个人的能力和外在条件的限制决定的，用上帝视角去看原来的问题是不太好的，学会在不确定性和不完全信息中调整航行的方向也许更重要。</p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/lato-font/3.0.0/css/lato-font.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcdn.net/ajax/libs/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>